- Write tests for:
  - parse_domain in client.c
  - cvm_ucspi_domain and cvm_setugid (?)

- Build a caching CVM proxy
  - Two hash tables keyed on binary request string.
  - First hash table for positive responses, holds raw response binary.
  - Second hash table for negative responses, holds only response code.
  - Caches positive response for $TTL seconds.
  - Caches negative response for $TTL_BAD seconds.
  - Do not cache temporary errors.

- Write up and implement CVM client->server protocol 2, which adds tags
  to the input format the same way the output has tags.

- Add support for allow/deny tables

  - File based: if $CVM_ACCESS/deny/$USER exists, or if
    $CVM_ACCESS/allow exists and $CVM_ACCESS/allow/$USER does not
    exist, deny the user.  Call a common function to test.

  - SQL modules: add an extra required boolean column to the query.

- Write a module to do lookups from a CDB file, as well as a tool to
  manipulate that file "cdbpasswd".

- Document the second protocol as either CVM2 or XCVM.
  - See http://lists.em.ca/?command=monthbythread&list=bgware&month=200105

- Stop using perror.

- Stop using stdio.

- Write cvm UDP-to-command and local-to-command relays:
  - recv input block from socket
  - spawn command
  - write block
  - read result
  - send result back on socket

- Split into cvm (containing the main modules) and lib/cvm (containing
  the client/module code).

- Consider how to do a "union" module that would call other modules and
  use the results from the first one that succeeds.

cvm-*sql:

- Call PQclearn(result) in cvm-pgsql.c

- Add support for allow/deny tables

- SQL modules: add an extra required boolean column to the query.

cvm-vmailmgr:

- Add code to vmailmgr_auth to try to grab the password from /etc/passwd
  if the main authentication fails.

- Write modules for authenticating against a vmailmgrd daemon, both
  local and (TCP) remote.
